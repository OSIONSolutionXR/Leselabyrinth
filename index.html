<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OSION Solution XR – Leselabyrinth MVP</title>
  <style>
    :root{
      /* Brand + kinderfreundlich */
      --bg1:#070a18;
      --bg2:#241055;
      --bg3:#43114a;

      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(255,255,255,.14);

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);

      --pink:#ff3fa9;
      --violet:#7b4dff;
      --cyan:#2ee3ff;
      --lime:#7CFF5C;
      --gold:#ffd24d;

      --ok:#28d17c;
      --bad:#ff4b6e;
      --warn:#ffb84d;

      --shadow: 0 20px 60px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 24px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--font);
      color: var(--text);
      background:
        radial-gradient(1200px 600px at 10% 20%, rgba(123,77,255,.35), transparent 55%),
        radial-gradient(900px 700px at 80% 30%, rgba(255,63,169,.25), transparent 55%),
        radial-gradient(1000px 700px at 40% 90%, rgba(46,227,255,.20), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2) 55%, var(--bg3));
      overflow-x:hidden;
    }

    /* leichte Sternchen */
    body:before{
      content:"";
      position:fixed; inset:0;
      background-image:
        radial-gradient(rgba(255,255,255,.13) 1px, transparent 1px);
      background-size: 38px 38px;
      opacity:.18;
      pointer-events:none;
      transform: translateZ(0);
    }

    .topbar{
      position:sticky; top:0; z-index:50;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      padding:14px 18px;
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.05));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .brand{
      display:flex; flex-direction:column; gap:2px;
      min-width: 240px;
    }
    .brand .title{
      font-weight: 900;
      letter-spacing:.4px;
      font-size: 15px;
      color: var(--pink);
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }

    .actions{
      display:flex; gap:10px; align-items:center;
    }

    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:10px 12px;
      border-radius: 999px;
      font-weight: 800;
      cursor:pointer;
      transition: transform .15s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.10);
      border-color: rgba(255,255,255,.20);
    }
    .btn.primary{
      background: linear-gradient(90deg, rgba(255,63,169,.95), rgba(123,77,255,.95));
      border-color: rgba(255,255,255,.18);
      box-shadow: 0 12px 30px rgba(255,63,169,.18);
    }
    .btn.ghost{
      background: rgba(255,255,255,.05);
    }
    .btn.danger{
      background: rgba(255,75,110,.10);
      border-color: rgba(255,75,110,.25);
    }

    .wrap{
      max-width: 1180px;
      margin: 18px auto 40px;
      padding: 0 16px;
      display:grid;
      grid-template-columns: 260px 1fr;
      gap: 14px;
      align-items:start;
    }

    @media (max-width: 980px){
      .wrap{grid-template-columns: 1fr}
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    /* Minimalistische Leiste oben im Spiel */
    .miniBar{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.15);
      flex-wrap:wrap;
    }

    .pill{
      display:flex; gap:8px; align-items:center;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      font-size: 12px;
      color: var(--text);
      user-select:none;
    }
    .pill b{
      font-size: 12px;
      opacity:.75;
      letter-spacing:.2px;
    }
    .pill .v{
      font-size: 12px;
      color: rgba(255,255,255,.92);
    }
    .pill.badgePink{ border-color: rgba(255,63,169,.28); background: rgba(255,63,169,.10); }
    .pill.badgeCyan{ border-color: rgba(46,227,255,.26); background: rgba(46,227,255,.09); }
    .pill.badgeGold{ border-color: rgba(255,210,77,.26); background: rgba(255,210,77,.10); }
    .pill.badgeLime{ border-color: rgba(124,255,92,.22); background: rgba(124,255,92,.08); }

    .pill.right{
      margin-left:auto;
    }

    .chapterPanel{
      padding: 12px;
    }
    .chapterTitle{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      margin-bottom: 10px;
    }
    .chapterTitle .h{
      font-weight: 1000;
      letter-spacing:.2px;
      font-size: 13px;
      color: rgba(255,255,255,.92);
    }
    .chapterTitle .tag{
      font-size:12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      user-select:none;
    }

    .nodeList{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .nodeBtn{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      cursor:pointer;
      transition: transform .15s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .nodeBtn:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.08);
      border-color: rgba(255,255,255,.18);
    }
    .nodeBtn[aria-disabled="true"]{
      opacity:.50;
      cursor:not-allowed;
      transform:none !important;
      filter: grayscale(.2);
    }

    .nodeLeft{
      display:flex; flex-direction:column; gap:2px;
      min-width: 0;
    }
    .nodeLeft .small{
      font-size: 11px;
      color: var(--muted);
      font-weight: 800;
    }
    .nodeLeft .name{
      font-size: 13px;
      font-weight: 1000;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .nodeState{
      font-size: 11px;
      font-weight: 1000;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      flex: 0 0 auto;
    }
    .nodeState.done{ border-color: rgba(40,209,124,.30); background: rgba(40,209,124,.12); }
    .nodeState.ready{ border-color: rgba(255,210,77,.30); background: rgba(255,210,77,.10); }
    .nodeState.lock{ border-color: rgba(255,255,255,.12); background: rgba(255,255,255,.05); }

    /* Main */
    .main{
      padding: 0;
    }

    .guideStrip{
      display:flex;
      align-items:center;
      gap:12px;
      padding: 12px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(90deg, rgba(255,63,169,.12), rgba(46,227,255,.08), rgba(124,255,92,.06));
    }

    .avatar{
      width:42px; height:42px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.16);
      background: radial-gradient(circle at 30% 30%, rgba(255,210,77,.35), rgba(123,77,255,.20));
      display:flex; align-items:center; justify-content:center;
      font-weight: 1000;
      color: rgba(255,255,255,.92);
      flex: 0 0 auto;
      box-shadow: 0 14px 30px rgba(0,0,0,.25);
    }

    .guideText{
      display:flex; flex-direction:column; gap:4px;
      min-width: 0;
    }
    .guideText .who{
      font-weight: 1000;
      font-size: 13px;
      letter-spacing:.2px;
    }
    .guideText .msg{
      font-weight: 900;
      font-size: 13px;
      color: rgba(255,255,255,.84);
      line-height: 1.25;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .card{
      padding: 14px;
      display:grid;
      gap: 12px;
    }

    .rowTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .rowTop .quest{
      font-weight: 1000;
      letter-spacing:.2px;
      font-size: 14px;
      color: rgba(255,255,255,.92);
    }
    .rowTop .chips{
      display:flex; gap:8px; flex-wrap:wrap;
    }
    .chip{
      font-size: 12px;
      font-weight: 1000;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      user-select:none;
    }

    .sceneBox{
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      overflow:hidden;
      position:relative;
    }

    .sceneHint{
      position:absolute;
      right: 10px;
      top: 10px;
      padding: 8px 10px;
      font-weight: 1000;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: rgba(255,255,255,.86);
      backdrop-filter: blur(8px);
      user-select:none;
    }

    .hotTip{
      padding: 10px 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      background: rgba(0,0,0,.12);
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight: 1000;
      font-size: 12px;
      user-select:none;
    }

    .readBlock{
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(500px 180px at 20% 30%, rgba(255,210,77,.14), transparent 55%),
        radial-gradient(500px 220px at 80% 50%, rgba(46,227,255,.12), transparent 60%),
        rgba(255,255,255,.05);
      padding: 14px;
      display:grid;
      gap: 10px;
      position:relative;
    }
    .readLabel{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      font-weight: 1000;
      letter-spacing:.3px;
      font-size: 12px;
      color: rgba(255,255,255,.84);
      text-transform: uppercase;
    }
    .readText{
      font-weight: 1000;
      font-size: 26px;            /* groß für Kinder */
      line-height: 1.35;
      color: rgba(255,255,255,.96);
      padding-right: 10px;
    }
    @media (max-width: 780px){
      .readText{ font-size: 22px; }
    }

    .readText .hl{
      padding: 0 .16em;
      border-radius: .35em;
      background: rgba(255,210,77,.18);
      border: 1px solid rgba(255,210,77,.18);
      box-shadow: 0 10px 24px rgba(255,210,77,.08);
    }

    .qBlock{
      border-radius: var(--radius);
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding: 14px;
      display:grid;
      gap: 10px;
    }
    .qTitle{
      font-weight: 1000;
      font-size: 20px;           /* größer */
      color: rgba(255,255,255,.96);
      letter-spacing:.2px;
    }

    .answers{
      display:grid;
      gap:10px;
    }

    .ans{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      padding: 14px 14px;
      font-size: 18px;           /* größer */
      font-weight: 1000;
      background:
        radial-gradient(600px 120px at 20% 20%, rgba(255,63,169,.10), transparent 55%),
        radial-gradient(600px 140px at 80% 40%, rgba(46,227,255,.10), transparent 60%),
        rgba(255,255,255,.06);
      cursor:pointer;
      transition: transform .15s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;
      position:relative;
      overflow:hidden;
      user-select:none;
    }
    .ans:before{
      content:"";
      position:absolute; inset:-40%;
      background: linear-gradient(120deg, transparent 40%, rgba(255,255,255,.16), transparent 60%);
      transform: translateX(-40%) rotate(12deg);
      animation: shine 2.6s ease-in-out infinite;
      opacity:.55;
      pointer-events:none;
    }
    @keyframes shine{
      0%{ transform: translateX(-60%) rotate(12deg); opacity:.0; }
      25%{ opacity:.55; }
      50%{ transform: translateX(20%) rotate(12deg); opacity:.35; }
      100%{ transform: translateX(60%) rotate(12deg); opacity:0; }
    }
    .ans:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.20);
      box-shadow: 0 16px 34px rgba(0,0,0,.22);
      background:
        radial-gradient(600px 120px at 20% 20%, rgba(124,255,92,.12), transparent 55%),
        radial-gradient(600px 140px at 80% 40%, rgba(255,210,77,.12), transparent 60%),
        rgba(255,255,255,.07);
    }

    .ans.correct{
      border-color: rgba(40,209,124,.38);
      background:
        radial-gradient(700px 140px at 20% 20%, rgba(40,209,124,.22), transparent 55%),
        radial-gradient(700px 160px at 80% 40%, rgba(255,210,77,.16), transparent 60%),
        rgba(40,209,124,.08);
    }
    .ans.wrong{
      border-color: rgba(255,75,110,.45);
      background:
        radial-gradient(700px 140px at 20% 20%, rgba(255,75,110,.22), transparent 55%),
        radial-gradient(700px 160px at 80% 40%, rgba(123,77,255,.12), transparent 60%),
        rgba(255,75,110,.07);
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 2px;
    }

    .mini{
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-weight: 1000;
      cursor:pointer;
      transition: transform .15s ease, background .2s ease;
      user-select:none;
    }
    .mini:hover{ transform: translateY(-1px); background: rgba(255,255,255,.08); }
    .mini[aria-disabled="true"]{ opacity:.55; cursor:not-allowed; transform:none; }

    .statusLine{
      border-radius: 16px;
      border:1px dashed rgba(255,255,255,.16);
      padding: 12px 12px;
      color: rgba(255,255,255,.86);
      background: rgba(0,0,0,.12);
      font-weight: 900;
      font-size: 13px;
      line-height: 1.3;
    }
    .statusLine.good{
      border-color: rgba(40,209,124,.35);
      background: rgba(40,209,124,.08);
      color: rgba(255,255,255,.92);
    }
    .statusLine.bad{
      border-color: rgba(255,75,110,.40);
      background: rgba(255,75,110,.08);
    }
    .statusLine.neutral{
      border-color: rgba(255,210,77,.30);
      background: rgba(255,210,77,.06);
    }

    /* Big star reward overlay */
    .reward{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:200;
      pointer-events:none;
      background: radial-gradient(800px 600px at 50% 45%, rgba(255,210,77,.18), rgba(0,0,0,.70));
    }
    .reward.show{ display:flex; }
    .starWrap{
      width:min(520px, 82vw);
      aspect-ratio: 1 / 1;
      position:relative;
      filter: drop-shadow(0 30px 60px rgba(0,0,0,.45));
      animation: pop .55s cubic-bezier(.18,1.2,.3,1) forwards;
    }
    @keyframes pop{
      0%{ transform: scale(.40) rotate(-18deg); opacity:0; }
      70%{ transform: scale(1.05) rotate(6deg); opacity:1; }
      100%{ transform: scale(1) rotate(0deg); opacity:1; }
    }
    .spark{
      position:absolute; inset:-15%;
      border-radius: 999px;
      background: conic-gradient(from 0deg,
        rgba(255,210,77,.0),
        rgba(255,210,77,.35),
        rgba(46,227,255,.25),
        rgba(255,63,169,.25),
        rgba(124,255,92,.20),
        rgba(255,210,77,.0)
      );
      animation: spin 1.2s linear infinite;
      filter: blur(1px);
      opacity:.9;
    }
    @keyframes spin{
      0%{ transform: rotate(0deg); }
      100%{ transform: rotate(360deg); }
    }
    .starSvg{
      position:absolute; inset:0;
      display:block;
    }
    .rewardText{
      position:absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      padding: 10px 14px;
      border-radius: 999px;
      font-weight: 1000;
      text-align:center;
      color: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
      box-shadow: 0 20px 40px rgba(0,0,0,.25);
      white-space:nowrap;
    }

    /* Diagnose */
    .diag{
      padding: 14px;
      display:none;
      gap: 12px;
    }
    .diag.show{ display:grid; }
    .diag h2{
      margin: 0;
      font-size: 16px;
      letter-spacing:.2px;
      font-weight: 1000;
    }
    .grid2{
      display:grid;
      gap: 12px;
      grid-template-columns: 1fr 1fr;
    }
    @media (max-width: 980px){ .grid2{ grid-template-columns: 1fr; } }

    .diagCard{
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .kpis{
      display:grid;
      gap: 10px;
      grid-template-columns: repeat(3, 1fr);
    }
    @media (max-width: 650px){ .kpis{ grid-template-columns: 1fr; } }
    .kpi{
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .kpi .k{
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
    }
    .kpi .v{
      font-size: 18px;
      font-weight: 1000;
      color: rgba(255,255,255,.92);
    }

    .list{
      display:grid;
      gap:8px;
    }
    .li{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.10);
      font-weight: 900;
      font-size: 13px;
    }
    .li small{ color: var(--muted); font-weight: 900; }
    .muted{ color: var(--muted); }

    /* hidden */
    .hide{ display:none !important; }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="brand">
      <div class="title">OSION Solution XR</div>
      <div class="sub">Leselabyrinth • Funkelwald (MVP) • Adventure + Adaptiv + Diagnose</div>
    </div>

    <div class="actions">
      <button class="btn primary" id="btnAdventure" type="button">Adventure</button>
      <button class="btn" id="btnDiagnose" type="button">Diagnose</button>
      <button class="btn danger" id="btnReset" type="button">Reset</button>
    </div>
  </div>

  <div class="wrap">
    <!-- Left: Kapitel-Pfad -->
    <aside class="panel">
      <div class="chapterPanel">
        <div class="chapterTitle">
          <div class="h" id="chapterName">Kapitel: Funkelwald</div>
          <div class="tag" id="pathTag">Pfad</div>
        </div>

        <div class="nodeList" id="nodeList"></div>

        <div style="margin-top:10px" class="muted">
          <div style="font-size:12px; font-weight:900; line-height:1.35;">
            Daten bleiben im Browser (LocalStorage). Kein Server. Ideal für GitHub Pages.
          </div>
        </div>
      </div>
    </aside>

    <!-- Main -->
    <main class="panel main">
      <!-- Minimalistische Info-Leiste -->
      <div class="miniBar">
        <div class="pill badgeGold"><b>Sterne</b> <span class="v" id="kpiStars">0</span></div>
        <div class="pill badgePink"><b>Serie</b> <span class="v" id="kpiStreak">0</span></div>
        <div class="pill badgeCyan"><b>Stufe</b> <span class="v" id="kpiLevel">1</span></div>
        <div class="pill badgeLime"><b>Fokus</b> <span class="v" id="kpiFocus">W-Frage</span></div>

        <div class="pill right"><b>Knoten</b> <span class="v" id="kpiProgress">0 / 5</span></div>
      </div>

      <!-- Guide -->
      <div class="guideStrip">
        <div class="avatar" id="avatar">F</div>
        <div class="guideText">
          <div class="who" id="guideName">Fips der Funkenkobold</div>
          <div class="msg" id="guideMsg">Lies den Text. Dann beantworte die Frage. Sammle Sterne.</div>
        </div>
      </div>

      <!-- Adventure view -->
      <section class="card" id="viewAdventure">
        <div class="rowTop">
          <div class="quest" id="questTitle">Quest: Waldweg</div>
          <div class="chips">
            <div class="chip" id="chipNode">Knoten: N1</div>
            <div class="chip" id="chipStatus">Status: offen</div>
            <div class="chip" id="chipMode">Modus: Quest</div>
          </div>
        </div>

        <div class="sceneBox">
          <div class="sceneHint" id="sceneHint">Tippe ins Bild: Dinge entdecken</div>
          <div id="sceneHost"></div>
          <div class="hotTip" id="hotTip"></div>
        </div>

        <div class="readBlock">
          <div class="readLabel">
            <span>Lesetext</span>
            <span class="muted" id="readSideNote">Erst lesen, dann antworten.</span>
          </div>
          <div class="readText" id="readText">…</div>
        </div>

        <div class="qBlock">
          <div class="qTitle" id="qTitle">Frage</div>
          <div class="answers" id="answers"></div>

          <div class="controls">
            <button class="mini" id="btnReadAgain" type="button">Nochmal lesen</button>
            <button class="mini" id="btnHelp" type="button">Hilfe</button>
            <span class="badge" id="triesBadge">Versuche: 0</span>
            <span class="badge" id="secretBadge">Geheimfunke: 0 / 1</span>
          </div>

          <div class="statusLine neutral" id="statusLine">Text im Fokus.</div>
        </div>
      </section>

      <!-- Diagnose view -->
      <section class="diag" id="viewDiagnose">
        <h2>Diagnose</h2>

        <div class="diagCard">
          <div class="kpis">
            <div class="kpi"><div class="k">Abgeschlossen</div><div class="v" id="dDone">0</div></div>
            <div class="kpi"><div class="k">Trefferquote</div><div class="v" id="dAcc">0%</div></div>
            <div class="kpi"><div class="k">Ø Zeit / Aufgabe</div><div class="v" id="dTime">0s</div></div>
          </div>
          <div class="muted" id="dSummary">Noch keine Daten. Spiele ein paar Karten.</div>
        </div>

        <div class="grid2">
          <div class="diagCard">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
              <div style="font-weight:1000;">Stärken</div>
              <small class="muted">Top</small>
            </div>
            <div class="list" id="dStrengths"></div>
          </div>

          <div class="diagCard">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
              <div style="font-weight:1000;">Fokus</div>
              <small class="muted">Nächster Schritt</small>
            </div>
            <div class="list" id="dFocus"></div>
          </div>
        </div>

        <div class="diagCard">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
            <div style="font-weight:1000;">Fehlmuster</div>
            <small class="muted">Top 5</small>
          </div>
          <div class="list" id="dPatterns"></div>
        </div>
      </section>
    </main>
  </div>

  <!-- Reward overlay -->
  <div class="reward" id="reward">
    <div class="starWrap">
      <div class="spark"></div>
      <svg class="starSvg" viewBox="0 0 200 200" aria-hidden="true">
        <defs>
          <radialGradient id="gStar" cx="35%" cy="30%" r="70%">
            <stop offset="0%" stop-color="rgba(255,255,255,.95)"/>
            <stop offset="45%" stop-color="rgba(255,210,77,.90)"/>
            <stop offset="100%" stop-color="rgba(255,63,169,.28)"/>
          </radialGradient>
          <filter id="glowBig" x="-30%" y="-30%" width="160%" height="160%">
            <feGaussianBlur stdDeviation="6" result="b"/>
            <feMerge>
              <feMergeNode in="b"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
        <path filter="url(#glowBig)" fill="url(#gStar)"
          d="M100 18 L122 70 L178 74 L134 110 L148 166 L100 136 L52 166 L66 110 L22 74 L78 70 Z"/>
      </svg>
      <div class="rewardText" id="rewardText">Stern erhalten</div>
    </div>
  </div>

<script>
/* =========================================================
   OSION Solution XR – Leselabyrinth MVP (Single File)
   Stabil: keine JSON-Dateien, keine externen Assets
   ========================================================= */

(function(){
  "use strict";

  /* ---------------------------
     Helpers
  --------------------------- */
  const $ = (id)=>document.getElementById(id);
  const now = ()=>Date.now();
  const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
  const rand = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  function safeJsonParse(s, fallback){
    try{ return JSON.parse(s); }catch(e){ return fallback; }
  }

  /* ---------------------------
     Local Storage
  --------------------------- */
  const LS_KEY = "osion_xr_leselabyrinth_v1";

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    const base = {
      monsterName: "Fips der Funkenkobold",
      chapterId: "funkelwald",
      level: 1,              // 1..3
      stars: 0,
      streak: 0,
      secret: 0,
      unlocked: ["N1"],
      done: [],
      currentNode: "N1",
      tries: 0,
      lastStartTs: 0,
      logs: []               // {ts,node,focus,correct,ms,wrongOptionId}
    };
    if(!raw) return base;
    const s = safeJsonParse(raw, base);
    // Hardening
    s.level = clamp(Number(s.level||1),1,3);
    s.stars = Number(s.stars||0);
    s.streak = Number(s.streak||0);
    s.secret = Number(s.secret||0);
    s.unlocked = Array.isArray(s.unlocked)? s.unlocked : ["N1"];
    s.done = Array.isArray(s.done)? s.done : [];
    s.logs = Array.isArray(s.logs)? s.logs : [];
    s.currentNode = s.currentNode || "N1";
    s.tries = Number(s.tries||0);
    s.lastStartTs = Number(s.lastStartTs||0);
    return s;
  }

  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  function resetState(){
    localStorage.removeItem(LS_KEY);
    location.reload();
  }

  /* ---------------------------
     Content (im Code, kein JSON extern)
     Kapitel: Funkelwald (5 Knoten)
  --------------------------- */
  const FOCUS = {
    W: "W-Frage",
    DETAIL: "Detail",
    WORD: "Wortverwechslung",
    ORDER: "Reihenfolge",
    CAUSE: "Ursache/Wirkung"
  };

  // Pro Node: 3 Stufenvarianten (level 1..3)
  // Wichtig: Frage muss IM Text beantwortbar sein (dein Kritikpunkt Apfel/Grün).
  const CHAPTER = {
    id: "funkelwald",
    name: "Funkelwald",
    nodes: [
      {
        id:"N1",
        name:"Waldweg",
        scene:"Waldweg",
        focusKey:"W",
        hotspots: [
          {id:"bird", label:"Vogel"},
          {id:"tree", label:"Baum"}
        ],
        cardsByLevel: {
          1: {
            text: "Fips geht in den Wald. Ein Vogel singt.",
            question: "Wohin geht Fips?",
            options: [
              {id:"a", text:"In den Wald.", correct:true, hintKey:"Wald"},
              {id:"b", text:"In die Stadt.", correct:false},
              {id:"c", text:"Ins Meer.", correct:false}
            ],
            help: "Suche im Text das Wort, das zur Frage passt."
          },
          2: {
            text: "Fips läuft den Waldweg entlang. Ein Vogel singt laut.",
            question: "Wer singt?",
            options: [
              {id:"a", text:"Der Vogel.", correct:true, hintKey:"Vogel"},
              {id:"b", text:"Der Frosch.", correct:false},
              {id:"c", text:"Der Hund.", correct:false}
            ],
            help: "Achte auf das Nomen im Satz."
          },
          3: {
            text: "Fips läuft den Waldweg entlang. Ein Vogel singt laut. Fips bleibt kurz stehen.",
            question: "Was macht Fips am Ende?",
            options: [
              {id:"a", text:"Er bleibt stehen.", correct:true, hintKey:"stehen"},
              {id:"b", text:"Er schwimmt.", correct:false},
              {id:"c", text:"Er fliegt.", correct:false}
            ],
            help: "Lies den letzten Satz nochmal."
          }
        }
      },
      {
        id:"N2",
        name:"Holzbrücke",
        scene:"Holzbrücke",
        focusKey:"DETAIL",
        hotspots: [
          {id:"bridge", label:"Brücke"},
          {id:"wood", label:"Holz"}
        ],
        cardsByLevel:{
          1:{
            text: "Vor Fips ist eine Brücke. Die Brücke ist aus Holz.",
            question:"Woraus ist die Brücke?",
            options:[
              {id:"a", text:"Aus Holz.", correct:true, hintKey:"Holz"},
              {id:"b", text:"Aus Eis.", correct:false},
              {id:"c", text:"Aus Stein.", correct:false}
            ],
            help:"Im Text steht das Material."
          },
          2:{
            text: "Vor Fips ist eine Brücke. Die Brücke ist aus Holz. Sie knarrt leise.",
            question:"Wie klingt die Brücke?",
            options:[
              {id:"a", text:"Sie knarrt leise.", correct:true, hintKey:"knarrt"},
              {id:"b", text:"Sie brüllt laut.", correct:false},
              {id:"c", text:"Sie pfeift.", correct:false}
            ],
            help:"Suche das Wort, das einen Ton beschreibt."
          },
          3:{
            text: "Vor Fips ist eine Brücke. Die Brücke ist aus Holz. Sie knarrt leise. Fips geht langsam.",
            question:"Wie geht Fips?",
            options:[
              {id:"a", text:"Langsam.", correct:true, hintKey:"langsam"},
              {id:"b", text:"Mit dem Fahrrad.", correct:false},
              {id:"c", text:"Rückwärts.", correct:false}
            ],
            help:"Das letzte Wort gibt die Antwort."
          }
        }
      },
      {
        id:"N3",
        name:"Apfelbaum",
        scene:"Apfelbaum",
        focusKey:"WORD",
        hotspots:[
          {id:"apple", label:"Apfel"},
          {id:"grass", label:"Wiese"}
        ],
        cardsByLevel:{
          1:{
            text:"Ein grüner Apfel fällt runter. Fips schaut hin.",
            question:"Welche Farbe hat der Apfel?",
            options:[
              {id:"a", text:"Grün.", correct:true, hintKey:"grüner"},
              {id:"b", text:"Blau.", correct:false},
              {id:"c", text:"Schwarz.", correct:false}
            ],
            help:"Das Adjektiv vor Apfel verrät die Farbe."
          },
          2:{
            text:"Ein grüner Apfel fällt runter. Fips schaut hin. Der Apfel rollt ins Gras.",
            question:"Wohin rollt der Apfel?",
            options:[
              {id:"a", text:"Ins Gras.", correct:true, hintKey:"Gras"},
              {id:"b", text:"In den Himmel.", correct:false},
              {id:"c", text:"In die Tasche.", correct:false}
            ],
            help:"Suche das Zielwort nach rollt."
          },
          3:{
            text:"Ein grüner Apfel fällt runter. Fips schaut hin. Der Apfel rollt ins Gras. Fips lacht leise.",
            question:"Was macht Fips?",
            options:[
              {id:"a", text:"Er lacht leise.", correct:true, hintKey:"lacht"},
              {id:"b", text:"Er schreit.", correct:false},
              {id:"c", text:"Er schläft.", correct:false}
            ],
            help:"Die letzte Zeile enthält die Antwort."
          }
        }
      },
      {
        id:"N4",
        name:"Sternstein",
        scene:"Sternstein",
        focusKey:"DETAIL",
        hotspots:[
          {id:"stone", label:"Stein"},
          {id:"star", label:"Stern"}
        ],
        cardsByLevel:{
          1:{
            text:"Fips findet einen Stein. Auf dem Stein ist ein Stern. Der Stern glitzert.",
            question:"Was ist auf dem Stein?",
            options:[
              {id:"a", text:"Ein Stern.", correct:true, hintKey:"Stern"},
              {id:"b", text:"Ein Haus.", correct:false},
              {id:"c", text:"Ein Auto.", correct:false}
            ],
            help:"Wort für Wort lesen: auf dem Stein ist …"
          },
          2:{
            text:"Fips findet einen Stein. Auf dem Stein ist ein Stern. Der Stern glitzert hell.",
            question:"Wie glitzert der Stern?",
            options:[
              {id:"a", text:"Hell.", correct:true, hintKey:"hell"},
              {id:"b", text:"Dunkel.", correct:false},
              {id:"c", text:"Gar nicht.", correct:false}
            ],
            help:"Das letzte Wort beschreibt das Glitzern."
          },
          3:{
            text:"Fips findet einen Stein. Auf dem Stein ist ein Stern. Der Stern glitzert hell. Fips hebt den Stein hoch.",
            question:"Was macht Fips mit dem Stein?",
            options:[
              {id:"a", text:"Er hebt ihn hoch.", correct:true, hintKey:"hebt"},
              {id:"b", text:"Er wirft ihn weg.", correct:false},
              {id:"c", text:"Er isst ihn.", correct:false}
            ],
            help:"Das Verb zeigt die Handlung."
          }
        }
      },
      {
        id:"N5",
        name:"Boss-Tor",
        scene:"Boss-Tor",
        focusKey:"CAUSE",
        hotspots:[
          {id:"gate", label:"Tor"},
          {id:"lock", label:"Schloss"},
          {id:"apple", label:"Apfel"},
          {id:"star", label:"Stern"}
        ],
        cardsByLevel:{
          1:{
            text:"Vor Fips ist ein großes Tor. Das Tor ist zu. Fips braucht einen Schlüssel.",
            question:"Warum geht das Tor nicht auf?",
            options:[
              {id:"a", text:"Weil das Tor zu ist.", correct:true, hintKey:"zu"},
              {id:"b", text:"Weil Fips fliegt.", correct:false},
              {id:"c", text:"Weil es regnet.", correct:false}
            ],
            help:"Ursache steht als Aussage im Text."
          },
          2:{
            text:"Vor Fips ist ein großes Tor. Das Tor ist zu. Fips braucht einen Schlüssel. Ohne Schlüssel bleibt es zu.",
            question:"Was braucht Fips, damit es aufgeht?",
            options:[
              {id:"a", text:"Einen Schlüssel.", correct:true, hintKey:"Schlüssel"},
              {id:"b", text:"Einen Ball.", correct:false},
              {id:"c", text:"Eine Leiter.", correct:false}
            ],
            help:"Suche das Wort braucht."
          },
          3:{
            text:"Vor Fips ist ein großes Tor. Das Tor ist zu. Fips braucht einen Schlüssel. Ohne Schlüssel bleibt es zu. Fips sucht weiter im Funkelwald.",
            question:"Was macht Fips am Ende?",
            options:[
              {id:"a", text:"Er sucht weiter.", correct:true, hintKey:"sucht"},
              {id:"b", text:"Er schläft.", correct:false},
              {id:"c", text:"Er schwimmt.", correct:false}
            ],
            help:"Letzter Satz, letztes Verb."
          }
        }
      }
    ]
  };

  const NODE_BY_ID = Object.fromEntries(CHAPTER.nodes.map(n=>[n.id,n]));

  /* ---------------------------
     State
  --------------------------- */
  let state = loadState();

  /* ---------------------------
     UI refs
  --------------------------- */
  const ui = {
    // top buttons
    btnAdventure: $("btnAdventure"),
    btnDiagnose: $("btnDiagnose"),
    btnReset: $("btnReset"),

    // left
    chapterName: $("chapterName"),
    nodeList: $("nodeList"),

    // kpis
    kpiStars: $("kpiStars"),
    kpiStreak: $("kpiStreak"),
    kpiLevel: $("kpiLevel"),
    kpiFocus: $("kpiFocus"),
    kpiProgress: $("kpiProgress"),

    // guide
    avatar: $("avatar"),
    guideName: $("guideName"),
    guideMsg: $("guideMsg"),

    // adventure
    viewAdventure: $("viewAdventure"),
    questTitle: $("questTitle"),
    chipNode: $("chipNode"),
    chipStatus: $("chipStatus"),
    chipMode: $("chipMode"),

    sceneHost: $("sceneHost"),
    hotTip: $("hotTip"),
    sceneHint: $("sceneHint"),

    readText: $("readText"),
    qTitle: $("qTitle"),
    answers: $("answers"),
    btnReadAgain: $("btnReadAgain"),
    btnHelp: $("btnHelp"),
    triesBadge: $("triesBadge"),
    secretBadge: $("secretBadge"),
    statusLine: $("statusLine"),

    // diagnose
    viewDiagnose: $("viewDiagnose"),
    dDone: $("dDone"),
    dAcc: $("dAcc"),
    dTime: $("dTime"),
    dSummary: $("dSummary"),
    dStrengths: $("dStrengths"),
    dFocus: $("dFocus"),
    dPatterns: $("dPatterns"),

    // reward
    reward: $("reward"),
    rewardText: $("rewardText"),
  };

  /* ---------------------------
     Runtime: current rendered card (derived)
  --------------------------- */
  let currentCard = null; // {nodeId, level, text, question, options[], help, focusKey, scene, hotspots}
  let answered = false;
  let lastHighlightKey = ""; // for help/highlight
  let secretFoundThisCard = false;

  /* ---------------------------
     Scene rendering (STABIL)
  --------------------------- */
  function onHotspot(hotId, hotspots){
    if(!hotId) return;

    // Geheimfunke: 1 pro Karte möglich
    if(!secretFoundThisCard){
      // Wenn Hotspot zur Szene passt, geben wir einen Geheimfunken.
      // (MVP-Regel: erster Tap zählt.)
      secretFoundThisCard = true;
      state.secret += 1;
      saveState();
      ui.secretBadge.textContent = `Geheimfunke: ${secretFoundThisCard ? 1 : 0} / 1`;
      setGuideMsg("Geheimfunke gefunden. Sehr gut.");
      ui.statusLine.className = "statusLine good";
      ui.statusLine.textContent = "Geheimfunke eingesammelt. Jetzt den Text lesen und antworten.";
    } else {
      setGuideMsg("Du hast schon einen Geheimfunken auf dieser Karte.");
    }

    // Visual ping (kurz) durch Statusline
    ui.statusLine.className = "statusLine neutral";
    ui.statusLine.textContent = "Entdeckt. Lies jetzt den Text genau.";
  }

  function makeSceneSVG(sceneName, hotspots){
    const rect = (id,x,y,w,h)=>`
      <rect x="${x}" y="${y}" width="${w}" height="${h}" rx="14"
        fill="rgba(255,255,255,0)" stroke="rgba(255,255,255,0)"
        pointer-events="all" data-hot="${id}"></rect>
    `;

    const maps = [];
    if(sceneName==="Waldweg"){
      maps.push(rect("bird", 160, 90, 120, 90));
      maps.push(rect("tree", 110, 70, 200, 240));
    }
    if(sceneName==="Holzbrücke"){
      maps.push(rect("bridge", 290, 185, 320, 140));
      maps.push(rect("wood", 290, 185, 320, 140));
    }
    if(sceneName==="Apfelbaum"){
      maps.push(rect("apple", 650, 135, 120, 140));
      maps.push(rect("grass", 520, 240, 360, 105));
    }
    if(sceneName==="Sternstein"){
      maps.push(rect("stone", 340, 200, 260, 140));
      maps.push(rect("star", 390, 175, 160, 130));
    }
    if(sceneName.startsWith("Boss")){
      maps.push(rect("gate", 360, 80, 220, 240));
      maps.push(rect("lock", 470, 170, 120, 130));
      maps.push(rect("apple", 650, 135, 120, 140));
      maps.push(rect("star", 390, 175, 160, 130));
    }

    const svg = `
    <svg viewBox="0 0 900 360" width="100%" height="240" style="display:block;">
      <defs>
        <linearGradient id="sky" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="rgba(46,227,255,.20)"/>
          <stop offset="100%" stop-color="rgba(123,77,255,.14)"/>
        </linearGradient>
        <linearGradient id="ground" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="rgba(124,255,92,.18)"/>
          <stop offset="100%" stop-color="rgba(0,0,0,.08)"/>
        </linearGradient>
        <filter id="softGlow" x="-30%" y="-30%" width="160%" height="160%">
          <feGaussianBlur stdDeviation="6" result="blur"/>
          <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
        </filter>
      </defs>

      <rect x="0" y="0" width="900" height="360" fill="url(#sky)"/>

      <!-- Funkel-Partikel -->
      ${Array.from({length:24}).map((_,i)=>{
        const x = rand(40,860), y = rand(30,220), r = rand(2,4);
        const a = (Math.random()*0.35+0.18).toFixed(2);
        return `<circle cx="${x}" cy="${y}" r="${r}" fill="rgba(255,210,77,${a})" filter="url(#softGlow)"/>`;
      }).join("")}

      <path d="M0,250 C120,220 240,270 360,250 C520,225 640,290 900,255 L900,360 L0,360 Z" fill="url(#ground)"/>

      <!-- Bäume -->
      <g opacity=".95">
        <g transform="translate(120,80)">
          <rect x="46" y="130" width="34" height="90" rx="10" fill="rgba(120,80,40,.55)"/>
          <circle cx="64" cy="120" r="68" fill="rgba(40,255,198,.18)" filter="url(#softGlow)"/>
          <circle cx="40" cy="115" r="44" fill="rgba(124,255,92,.16)"/>
          <circle cx="86" cy="110" r="46" fill="rgba(46,227,255,.10)"/>
        </g>
        <g transform="translate(610,75)">
          <rect x="46" y="130" width="34" height="90" rx="10" fill="rgba(120,80,40,.52)"/>
          <circle cx="64" cy="120" r="70" fill="rgba(255,63,169,.12)" filter="url(#softGlow)"/>
          <circle cx="40" cy="115" r="44" fill="rgba(124,255,92,.14)"/>
          <circle cx="88" cy="112" r="48" fill="rgba(255,210,77,.10)"/>
        </g>
      </g>

      <!-- Pfad -->
      <path d="M430,360 C430,300 480,292 520,280 C600,255 590,230 540,210 C495,190 430,185 380,175 C310,160 250,150 220,120"
            fill="none" stroke="rgba(255,255,255,.12)" stroke-width="18" stroke-linecap="round"/>
      <path d="M430,360 C430,300 480,292 520,280 C600,255 590,230 540,210 C495,190 430,185 380,175 C310,160 250,150 220,120"
            fill="none" stroke="rgba(255,210,77,.16)" stroke-width="6" stroke-linecap="round" filter="url(#softGlow)"/>

      <!-- Scene objects -->
      ${sceneName==="Waldweg" ? `
        <g transform="translate(210,118)">
          <path d="M0,18 Q16,0 34,18 Q20,22 34,34 Q16,28 0,34 Q10,26 0,18 Z"
                fill="rgba(255,255,255,.20)" stroke="rgba(255,255,255,.18)" stroke-width="2"/>
          <circle cx="18" cy="18" r="3" fill="rgba(255,210,77,.95)"/>
        </g>` : ``}

      ${sceneName==="Holzbrücke" ? `
        <g transform="translate(450,240)">
          <rect x="-150" y="-14" width="300" height="28" rx="14" fill="rgba(120,80,40,.40)" stroke="rgba(255,255,255,.14)"/>
          ${Array.from({length:11}).map((_,i)=>`<rect x="${-140+i*28}" y="-10" width="18" height="20" rx="6" fill="rgba(255,255,255,.06)"/>`).join("")}
          <path d="M-165,-20 Q0,-58 165,-20" fill="none" stroke="rgba(255,210,77,.16)" stroke-width="7" stroke-linecap="round" filter="url(#softGlow)"/>
        </g>` : ``}

      ${sceneName==="Apfelbaum" ? `
        <g transform="translate(700,182)">
          <circle cx="0" cy="0" r="24" fill="rgba(124,255,92,.26)" stroke="rgba(255,255,255,.16)" stroke-width="2"/>
          <path d="M-3,-22 Q0,-38 16,-36" fill="none" stroke="rgba(120,80,40,.55)" stroke-width="4" stroke-linecap="round"/>
          <path d="M14,-36 Q34,-38 34,-20 Q18,-20 14,-36 Z" fill="rgba(40,255,198,.18)"/>
        </g>` : ``}

      ${sceneName==="Sternstein" ? `
        <g transform="translate(460,268)">
          <path d="M-90,0 Q-70,-68 0,-66 Q70,-68 90,0 Q45,52 0,47 Q-45,52 -90,0 Z"
                fill="rgba(255,255,255,.07)" stroke="rgba(255,255,255,.14)" stroke-width="2"/>
          <path d="M0,-46 L12,-14 L46,-12 L18,10 L28,44 L0,24 L-28,44 L-18,10 L-46,-12 L-12,-14 Z"
                fill="rgba(255,210,77,.24)" filter="url(#softGlow)"/>
        </g>` : ``}

      ${sceneName.startsWith("Boss") ? `
        <g transform="translate(450,200)">
          <rect x="-105" y="-100" width="210" height="185" rx="22" fill="rgba(255,255,255,.06)" stroke="rgba(255,255,255,.16)" stroke-width="2"/>
          <rect x="-82" y="-78" width="164" height="140" rx="18" fill="rgba(0,0,0,.18)" stroke="rgba(255,255,255,.10)"/>
          <circle cx="58" cy="-4" r="9" fill="rgba(255,210,77,.55)" filter="url(#softGlow)"/>
        </g>` : ``}

      <!-- Hotspots -->
      <g style="cursor:pointer;">
        ${maps.join("")}
      </g>

      <rect x="10" y="10" width="880" height="340" rx="18" fill="none" stroke="rgba(255,255,255,.10)"/>
    </svg>`;

    const container = document.createElement("div");
    container.innerHTML = svg;

    const svgEl = container.querySelector("svg");
    svgEl.addEventListener("click", (e)=>{
      const hot = e.target && e.target.getAttribute && e.target.getAttribute("data-hot");
      if(!hot) return;
      onHotspot(hot, hotspots || []);
    });

    return container;
  }

  function renderScene(sceneName, hotspots){
    ui.sceneHost.innerHTML = "";
    ui.sceneHost.style.minHeight = "240px";
    ui.sceneHost.appendChild(makeSceneSVG(sceneName, hotspots));

    const list = (hotspots||[]).map(h => `<span class="badge">${h.label}</span>`).join("");
    ui.hotTip.innerHTML = list ? list : `<span class="badge">Entdecken</span>`;
  }

  /* ---------------------------
     Card selection + rendering
  --------------------------- */
  function getFocusLabel(node){
    return FOCUS[node.focusKey] || "Lesen";
  }

  function buildCard(nodeId){
    const node = NODE_BY_ID[nodeId];
    const level = clamp(state.level,1,3);
    const c = node.cardsByLevel[level];

    // Wichtig: Antwort-Reihenfolge mischen
    const optionsShuffled = shuffle(c.options);

    return {
      nodeId,
      nodeName: node.name,
      scene: node.scene,
      focusKey: node.focusKey,
      focusLabel: getFocusLabel(node),
      hotspots: node.hotspots || [],
      level,
      text: c.text,
      question: c.question,
      options: optionsShuffled,
      help: c.help,
    };
  }

  function highlightText(text, key){
    if(!key) return escapeHtml(text);

    // markiere erstes Vorkommen (case-insensitive)
    const re = new RegExp(`(${escapeRegExp(key)})`, "i");
    const safe = escapeHtml(text);
    // Wir können nicht direkt im escaped string sauber matchen.
    // Deshalb machen wir es auf dem original und bauen neu:
    const m = text.match(re);
    if(!m) return escapeHtml(text);

    const idx = text.toLowerCase().indexOf(key.toLowerCase());
    if(idx < 0) return escapeHtml(text);

    const a = text.slice(0, idx);
    const b = text.slice(idx, idx + key.length);
    const c = text.slice(idx + key.length);
    return `${escapeHtml(a)}<span class="hl">${escapeHtml(b)}</span>${escapeHtml(c)}`;
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function escapeRegExp(s){
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function setGuideMsg(msg){
    ui.guideMsg.textContent = msg;
  }

  function setStatus(kind, text){
    ui.statusLine.className = "statusLine " + kind;
    ui.statusLine.textContent = text;
  }

  function renderAnswers(){
    ui.answers.innerHTML = "";
    currentCard.options.forEach(opt=>{
      const b = document.createElement("button");
      b.className = "ans";
      b.type = "button";
      b.textContent = opt.text;
      b.addEventListener("click", ()=>onAnswer(opt.id));
      ui.answers.appendChild(b);
    });
  }

  function renderCard(){
    answered = false;
    secretFoundThisCard = false;
    lastHighlightKey = "";

    currentCard = buildCard(state.currentNode);

    // header / chips
    ui.questTitle.textContent = `Quest: ${currentCard.nodeName}`;
    ui.chipNode.textContent = `Knoten: ${currentCard.nodeId}`;
    ui.chipStatus.textContent = `Status: ${state.done.includes(currentCard.nodeId) ? "erledigt" : "offen"}`;
    ui.chipMode.textContent = "Modus: Quest";

    // focus
    ui.kpiFocus.textContent = currentCard.focusLabel;

    // scene
    renderScene(currentCard.scene, currentCard.hotspots);

    // read text (groß, ohne Highlight zu Beginn)
    ui.readText.innerHTML = escapeHtml(currentCard.text);

    // question
    ui.qTitle.textContent = currentCard.question;

    // answers
    renderAnswers();

    // tries + secret
    state.tries = 0;
    ui.triesBadge.textContent = `Versuche: ${state.tries}`;
    ui.secretBadge.textContent = `Geheimfunke: ${secretFoundThisCard ? 1 : 0} / 1`;

    // status line
    setGuideMsg("Lies den Text. Dann beantworte die Frage.");
    setStatus("neutral", "Text im Fokus.");

    // timer
    state.lastStartTs = now();
    saveState();
  }

  /* ---------------------------
     Progress + Unlock logic
  --------------------------- */
  function nextNodeIdAfter(nodeId){
    const idx = CHAPTER.nodes.findIndex(n=>n.id===nodeId);
    if(idx < 0) return null;
    return CHAPTER.nodes[idx+1]?.id || null;
  }

  function unlockNextIfPossible(){
    const next = nextNodeIdAfter(state.currentNode);
    if(!next) return;
    if(state.unlocked.includes(next)) return;
    state.unlocked.push(next);
  }

  function markDone(nodeId){
    if(!state.done.includes(nodeId)){
      state.done.push(nodeId);
    }
    // unlock next node
    const next = nextNodeIdAfter(nodeId);
    if(next && !state.unlocked.includes(next)){
      state.unlocked.push(next);
    }
  }

  function isChapterComplete(){
    return state.done.length >= CHAPTER.nodes.length;
  }

  /* ---------------------------
     Adaptive leveling (simple + robust)
  --------------------------- */
  function adaptAfterAnswer(correct){
    if(correct){
      state.streak += 1;
      // 3 richtig -> level up
      if(state.streak >= 3){
        if(state.level < 3){
          state.level += 1;
          setGuideMsg("Level hoch. Du wirst stärker.");
        }
        state.streak = 0;
      }
    } else {
      state.streak = 0;
      // 2 Fehlversuche in dieser Karte -> Hilfen stärker
      // (wir steuern das über Highlight + Hilfe-Text)
    }
  }

  /* ---------------------------
     Reward animation (riesiger Stern)
  --------------------------- */
  function showReward(text){
    ui.rewardText.textContent = text;
    ui.reward.classList.add("show");
    setTimeout(()=>ui.reward.classList.remove("show"), 950);
  }

  /* ---------------------------
     Answer handling (FIX: kein Feststecken)
  --------------------------- */
  function onAnswer(optionId){
    if(answered) return;

    const opt = currentCard.options.find(o=>o.id===optionId);
    if(!opt) return;

    state.tries += 1;
    ui.triesBadge.textContent = `Versuche: ${state.tries}`;

    const ms = Math.max(1, now() - (state.lastStartTs || now()));

    // UI feedback on clicked button
    const buttons = Array.from(ui.answers.querySelectorAll(".ans"));
    const clickedIdx = currentCard.options.findIndex(o=>o.id===optionId);
    const clickedBtn = buttons[clickedIdx];

    if(opt.correct){
      answered = true;

      // mark UI
      if(clickedBtn) clickedBtn.classList.add("correct");

      // stars
      state.stars += 1;

      // log
      state.logs.push({
        ts: now(),
        node: currentCard.nodeId,
        focus: currentCard.focusKey,
        correct: true,
        ms: ms,
        wrongOptionId: null
      });

      // progress
      markDone(currentCard.nodeId);

      adaptAfterAnswer(true);

      // reward
      showReward("Stern erhalten");
      setStatus("good", "Richtig. Weiter geht’s.");

      // next move: automatisch zum nächsten offenen/unlocked
      const next = nextNodeIdAfter(currentCard.nodeId);
      saveState();
      renderAllKpis();
      renderLeftNav();

      if(next){
        // Auto-advance nur, wenn freigeschaltet
        state.currentNode = next;
        saveState();
        // kurzer Delay, damit Feedback sichtbar ist
        setTimeout(()=>renderCard(), 520);
      } else {
        // Kapitel fertig
        setGuideMsg("Kapitel abgeschlossen. Diagnose zeigt die Auswertung.");
        setStatus("good", "Kapitel abgeschlossen. Öffne Diagnose.");
      }

      return;
    }

    // wrong
    if(clickedBtn) clickedBtn.classList.add("wrong");
    setStatus("bad", "Noch nicht. Lies den Text nochmal und suche das passende Wort.");
    setGuideMsg("Nochmal lesen. Such das Wort, das zur Frage passt.");

    // log wrong
    state.logs.push({
      ts: now(),
      node: currentCard.nodeId,
      focus: currentCard.focusKey,
      correct: false,
      ms: ms,
      wrongOptionId: optionId
    });

    adaptAfterAnswer(false);

    // Hilfe-Mechanik: Highlight auf Hinweiswort der richtigen Antwort (ab 2 Fehlversuchen)
    if(state.tries >= 2){
      const right = currentCard.options.find(o=>o.correct);
      if(right && right.hintKey){
        lastHighlightKey = right.hintKey;
        ui.readText.innerHTML = highlightText(currentCard.text, lastHighlightKey);
        setStatus("neutral", `Tipp: Suche im Text nach dem markierten Wort.`);
      }
    }

    // Wichtig: NICHT answered=true setzen → Kind kann weiter klicken.
    // (Dein Bug war: state/answered wurde so gesetzt, dass nichts mehr geht.)
    saveState();
    renderAllKpis();
  }

  /* ---------------------------
     Read again + help
  --------------------------- */
  ui.btnReadAgain.addEventListener("click", ()=>{
    ui.readText.innerHTML = lastHighlightKey ? highlightText(currentCard.text, lastHighlightKey) : escapeHtml(currentCard.text);
    setStatus("neutral", "Nochmal lesen. Dann antworten.");
  });

  ui.btnHelp.addEventListener("click", ()=>{
    // Hilfe: ab 1 Klick highlight das Hint-Key der korrekten Option
    const right = currentCard.options.find(o=>o.correct);
    if(right && right.hintKey){
      lastHighlightKey = right.hintKey;
      ui.readText.innerHTML = highlightText(currentCard.text, lastHighlightKey);
      setGuideMsg(currentCard.help || "Suche das passende Wort im Text.");
      setStatus("neutral", "Hilfe aktiv. Lies den markierten Teil.");
    } else {
      setGuideMsg(currentCard.help || "Lies den Text langsam. Dann entscheide.");
      setStatus("neutral", "Hilfe aktiv.");
    }
  });

  /* ---------------------------
     Left nav render
  --------------------------- */
  function renderLeftNav(){
    ui.chapterName.textContent = `Kapitel: ${CHAPTER.name}`;
    ui.nodeList.innerHTML = "";

    CHAPTER.nodes.forEach((n, idx)=>{
      const done = state.done.includes(n.id);
      const unlocked = state.unlocked.includes(n.id);
      const isCurrent = state.currentNode === n.id;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "nodeBtn";
      btn.setAttribute("aria-disabled", unlocked ? "false" : "true");

      const left = document.createElement("div");
      left.className = "nodeLeft";
      left.innerHTML = `
        <div class="small">${idx+1}</div>
        <div class="name">${n.name}</div>
      `;

      const st = document.createElement("div");
      st.className = "nodeState " + (done ? "done" : (unlocked ? "ready" : "lock"));
      st.textContent = done ? "erledigt" : (unlocked ? (isCurrent ? "bereit" : "offen") : "gesperrt");

      btn.appendChild(left);
      btn.appendChild(st);

      if(!unlocked){
        btn.addEventListener("click", ()=>{
          setGuideMsg("Dieser Knoten ist noch gesperrt.");
          setStatus("neutral", "Erst den vorherigen Knoten erledigen.");
        });
      } else {
        btn.addEventListener("click", ()=>{
          state.currentNode = n.id;
          saveState();
          renderAllKpis();
          renderLeftNav();
          renderCard();
        });
      }

      ui.nodeList.appendChild(btn);
    });
  }

  /* ---------------------------
     KPIs render
  --------------------------- */
  function renderAllKpis(){
    ui.kpiStars.textContent = String(state.stars);
    ui.kpiStreak.textContent = String(state.streak);
    ui.kpiLevel.textContent = String(state.level);
    ui.kpiProgress.textContent = `${state.done.length} / ${CHAPTER.nodes.length}`;
    ui.avatar.textContent = "F";
    ui.guideName.textContent = state.monsterName;
  }

  /* ---------------------------
     Diagnose
  --------------------------- */
  function computeDiagnosis(){
    const logs = state.logs.slice();
    const done = state.done.length;
    const total = logs.length;
    const correct = logs.filter(x=>x.correct).length;
    const acc = total ? Math.round((correct/total)*100) : 0;

    const avgMs = logs.length ? Math.round(logs.reduce((a,b)=>a+b.ms,0)/logs.length) : 0;
    const avgS = Math.round(avgMs/100)/10; // 1 decimal

    // Fehlmuster nach focusKey bei falschen
    const wrong = logs.filter(x=>!x.correct);
    const wrongByFocus = {};
    wrong.forEach(w=>{
      wrongByFocus[w.focus] = (wrongByFocus[w.focus]||0)+1;
    });

    // Stärken nach focusKey bei richtigen
    const correctByFocus = {};
    logs.filter(x=>x.correct).forEach(w=>{
      correctByFocus[w.focus] = (correctByFocus[w.focus]||0)+1;
    });

    // Sort
    const patterns = Object.entries(wrongByFocus).sort((a,b)=>b[1]-a[1]).slice(0,5);
    const strengths = Object.entries(correctByFocus).sort((a,b)=>b[1]-a[1]).slice(0,3);

    // Fokus-Empfehlung: höchstes Fehlmuster
    const focusPick = patterns[0]?.[0] || null;

    // Text output
    return {done, acc, avgS, patterns, strengths, focusPick};
  }

  function renderDiagnosis(){
    const d = computeDiagnosis();
    ui.dDone.textContent = String(d.done);
    ui.dAcc.textContent = `${d.acc}%`;
    ui.dTime.textContent = `${d.avgS}s`;

    ui.dStrengths.innerHTML = "";
    if(d.strengths.length === 0){
      ui.dStrengths.innerHTML = `<div class="li"><span>Noch keine Stärken.</span><small>Spiele weiter</small></div>`;
    } else {
      d.strengths.forEach(([k,v])=>{
        ui.dStrengths.appendChild(li(`${FOCUS[k]||k}`, `${v}x`));
      });
    }

    ui.dPatterns.innerHTML = "";
    if(d.patterns.length === 0){
      ui.dPatterns.innerHTML = `<div class="li"><span>Keine Fehlmuster sichtbar.</span><small>Stabil</small></div>`;
    } else {
      d.patterns.forEach(([k,v])=>{
        ui.dPatterns.appendChild(li(`${FOCUS[k]||k}`, `${v}x`));
      });
    }

    ui.dFocus.innerHTML = "";
    if(!d.focusPick){
      ui.dFocus.innerHTML = `<div class="li"><span>Fokus: weiter spielen</span><small>Empfehlung</small></div>`;
    } else {
      ui.dFocus.appendChild(li(`Fokus: ${FOCUS[d.focusPick]||d.focusPick}`, "nächste Woche"));
      ui.dFocus.appendChild(li("Mission", "8 Minuten pro Tag"));
    }

    // Summary
    const s = [];
    if(d.done === 0){
      ui.dSummary.textContent = "Noch keine Daten. Spiele ein paar Karten und öffne dann Diagnose.";
    } else {
      s.push(`Abgeschlossen: ${d.done}/${CHAPTER.nodes.length}.`);
      s.push(`Trefferquote: ${d.acc}%.`);
      if(d.focusPick) s.push(`Fokus: ${FOCUS[d.focusPick]||d.focusPick}.`);
      ui.dSummary.textContent = s.join(" ");
    }
  }

  function li(left, right){
    const el = document.createElement("div");
    el.className = "li";
    el.innerHTML = `<span>${escapeHtml(left)}</span><small>${escapeHtml(right)}</small>`;
    return el;
  }

  /* ---------------------------
     View switching
  --------------------------- */
  function showAdventure(){
    ui.viewAdventure.classList.remove("hide");
    ui.viewDiagnose.classList.remove("show");
    ui.viewDiagnose.classList.add("hide");
    ui.btnAdventure.classList.add("primary");
    ui.btnDiagnose.classList.remove("primary");
  }
  function showDiagnose(){
    ui.viewAdventure.classList.add("hide");
    ui.viewDiagnose.classList.remove("hide");
    ui.viewDiagnose.classList.add("show");
    ui.btnDiagnose.classList.add("primary");
    ui.btnAdventure.classList.remove("primary");
    renderDiagnosis();
  }

  ui.btnAdventure.addEventListener("click", showAdventure);
  ui.btnDiagnose.addEventListener("click", showDiagnose);
  ui.btnReset.addEventListener("click", resetState);

  /* ---------------------------
     Boot hardening
  --------------------------- */
  function hardenState(){
    // sicherstellen, dass currentNode unlocked ist
    if(!state.unlocked.includes(state.currentNode)){
      state.currentNode = state.unlocked[0] || "N1";
    }
    // wenn currentNode done ist und es gibt next unlocked -> optional weiterschieben
    saveState();
  }

  /* ---------------------------
     Init
  --------------------------- */
  hardenState();
  renderAllKpis();
  renderLeftNav();
  renderCard();
  showAdventure();

})();
</script>
</body>
</html>
